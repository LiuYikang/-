### 令牌桶算法

令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务.

![](./assert/token_bucket.JPG)

令牌桶这种控制机制基于令牌桶中是否存在令牌来指示什么时候可以发送流量。令牌桶中的每一个令牌都代表一个字节。如果令牌桶中存在令牌，则允许发送流量；而如果令牌桶中不存在令牌，则不允许发送流量。因此，如果突发门限被合理地配置并且令牌桶中有足够的令牌，那么流量就可以以峰值速率发送。

算法描述：

* 假如用户配置的平均发送速率为r，则每隔1/QPS秒一个令牌被加入到桶中（每秒会有QPS个令牌放入桶中）；

* 假设桶中最多可以存放b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃；

* 当一个n个字节的数据包到达时，就从令牌桶中删除n个令牌（不同大小的数据包，消耗的令牌数量不一样），并且数据包被发送到网络；

* 如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外（n个字节，需要n个令牌。该数据包将被缓存或丢弃）；

* 算法允许最长b个字节的突发，但从长期运行结果看，数据包的速率被限制成常量QPS。对于在流量限制外的数据包可以以不同的方式处理：（1）它们可以被丢弃；（2）它们可以排放在队列中以便当令牌桶中累积了足够多的令牌时再传输；（3）它们可以继续发送，但需要做特殊标记，网络过载的时候将这些特殊标记的包丢弃。


令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量.

### 漏桶算法

漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.示意图如下:

![](./assets/rate-limit1.png)

可见这里有两个变量,一个是桶的大小,支持流量突发增多时可以存多少的水(burst),另一个是水桶漏洞的大小(rate)。

漏斗有一个进水口 和 一个出水口，出水口以一定速率出水，并且有一个最大出水速率：

在漏斗中没有水的时候:
* 如果进水速率小于等于最大出水速率，那么，出水速率等于进水速率，此时，不会积水
* 如果进水速率大于最大出水速率，那么，漏斗以最大速率出水，此时，多余的水会积在漏斗中

在漏斗中有水的时候
* 出水口以最大速率出水
* 如果漏斗未满，且有进水的话，那么这些水会积在漏斗中
* 如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外

因为漏桶的漏出速率是固定的参数,所以,即使网络中不存在资源冲突(没有发生拥塞),漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率.

### 对比
* 漏桶
漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。

* 令牌桶
生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。

## 系统设计

https://www.hiredintech.com/system-design

https://soulmachine.gitbooks.io/system-design/content/cn/

https://yuanhsh.iteye.com/blog/2194982

https://www.cnblogs.com/yunnotes/archive/2013/04/19/3032367.html

https://www.itcodemonkey.com/article/8126.html

https://blog.csdn.net/dennis_zane/article/details/83266137

[如何设计一个百万级用户的抽奖系统](https://juejin.im/post/5ce3f003f265da1bbd4b4946)

[如果让你设计一个消息中间件，如何将其网络通信性能优化10倍以上？](https://juejin.im/post/5cbc723cf265da03ac0d0930)

[支撑百万连接的系统应该如何设计其高并发架构](https://juejin.im/post/5c7fcf1be51d457d0353d5ea)

[写入消息中间件的数据，如何保证不丢失](https://juejin.im/post/5c7e7a046fb9a04a07311fe7)

[消息中间件如何实现每秒几十万的高并发写入](https://juejin.im/post/5c7bd09b6fb9a049ba424c15)

[20万用户同时访问一个热点缓存，如何优化你的缓存架构](https://juejin.im/post/5c448670e51d455bd36b67f9)

[你的系统如何支撑高并发？](https://juejin.im/post/5c45aaee6fb9a049e6609115)

设计一个微博的timeline，其中某些大V用户可能有千万级的关注量。

## 其他

### 蓄水池算法

[大数据工程师必备之蓄水池抽样算法](https://blog.csdn.net/bitcarmanlee/article/details/52719202)

### 断路器
[微服务的断路器实现图解Golang通用版](https://studygolang.com/articles/20437)

### 海量数据
https://blog.csdn.net/v_july_v/article/details/6279498
