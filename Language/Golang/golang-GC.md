## 1 GC过程
golang使用的是 **标记-清理（Mark-and-Sweep）** 来实现gc，标记-清除算法就是将可达的内存块进行标记mark，最后没有标记的不可达内存块将进行清理sweep。

### 1.1 golang GC触发条件

1. 在申请内存的时候，检查当前当前已分配的内存是否大于上次GC后的内存的 **2倍** ，若是则触发（主GC线程为当前M），这种不可靠，内存一旦上去之后，等到它变成两倍的时候时间会比较长；

2. 监控线程发现上次GC的时间已经超过 **两分钟** ，触发：将一个G任务放到全局G队列中去。（主GC线程为执行这个G任务的M）

### 1.2 标记-清除

判断一个对象是不是垃圾需不需要标记，就看是否能从当前栈或全局数据区直接或间接的引用到这个对象。这个初始的当前goroutine的栈和全局数据区称为GC的root区。扫描从这里开始，通过markroot将所有root区域的指针标记为可达，然后沿着这些指针扫描，递归地标记遇到的所有可达对象。

#### 三色标记算法
三色标记算法是对标记阶段的改进，原理如下：
1. 起初所有对象都是白色。
2. 从根出发扫描所有可达对象，标记为灰色，放入待处理队列。
3. 从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。
4. 重复3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。

参考图示：
![](./assets/Animation_of_tri-color_garbage_collection.gif)

参考：
[Golang 垃圾回收剖析](http://legendtkl.com/2017/04/28/golang-gc/) \
[golang的垃圾回收（GC）机制](https://blog.csdn.net/WangYouJin321/article/details/80481567)

## 2 逃逸分析

## 3 GC优化
