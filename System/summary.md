## 进程、线程和协程

### 区别
https://juejin.im/post/5b0014b7518825426e023666

### 进程通信
进程间是隔离的,各自拥有自己的内存内存资源, 因此相对于线程比较安全, 所以不同进程之间的数据只能通过 IPC(Inter-Process Communication) 进行通信共享。

IPC(Inter-Process Communication),指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:
1、低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)
2、高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等).

* 管道（pipe），管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
* 有名管道（FIFO），有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
* 信号（signal），信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生, **唯一的异步通信方式**。
* 套接字（socket)，套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
> 以下属于SystemV 通信机制
* 消息队列，消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
* 共享内存，**最快的IPC通信机制**，共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
* 信号量，信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。


### 线程通信和同步

线程间的通信目的主要是用于**线程同步**，所以线程没有像进程通信中的用于数据交换的通信机制。

#### 线程间的通信方式
* 锁机制：包括互斥锁、条件变量、读写锁和自旋锁。

   **互斥锁**确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。

   **读写锁**当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。

   **条件变量**可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

   **自旋锁**上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。

* 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

* 信号机制(Signal)：类似进程间的信号处理

### 线程切换过程
https://www.cnblogs.com/kkshaq/p/4547725.html

### 协程

## 死锁
死锁产生的必要条件：互斥、不可抢占、请求和保持、循环等待

避免死锁的方法：
1. 设置加锁顺序，线程按照一定的顺序加锁
2. 设置加锁时限，超时重试
3. 死锁检测

##
